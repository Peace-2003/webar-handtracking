<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pattern-Based Web AR Experience</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      font-family: Arial, sans-serif;
    }
    #ui-container {
      position: fixed;
      bottom: 20px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: center;
      z-index: 100;
    }
    .ui-button {
      margin: 0 10px;
      padding: 10px 15px;
      background-color: rgba(255, 255, 255, 0.7);
      border-radius: 10px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
    }
    .info-box {
      position: fixed;
      top: 20px;
      left: 20px;
      background-color: rgba(255, 255, 255, 0.7);
      padding: 10px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      z-index: 100;
      display: none;
    }
    #active-pattern {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: rgba(255, 255, 255, 0.7);
      padding: 10px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="loading">Loading AR Experience...</div>
  <div id="ui-container">
    <div class="ui-button" id="btn-help">Help</div>
    <div class="ui-button" id="btn-toggle-audio">Sound: OFF</div>
    <div class="ui-button" id="btn-toggle-motion">Motion: ON</div>
  </div>
  <div id="info-box" class="info-box">
    Point your camera at one of the target patterns to see the AR content
  </div>
  <div id="active-pattern">No pattern detected</div>
  
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.1/dist/mindar-image.prod.js"></script>
  <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.1/dist/mindar-image-aframe.prod.js"></script>
  <script src="js/main.js"></script>

  <!-- Custom components for persistent AR tracking -->
  <script>
    // Global AR state to maintain persistence across component lifecycles
    window.arPersistence = {
      activeContent: null,
      lastWorldPosition: new THREE.Vector3(),
      lastWorldQuaternion: new THREE.Quaternion(),
      hasDetectedPattern: false,
      // Add a list of all content entities for better management
      contentEntities: [],
      persistentParents: [],
      // Current active pattern (or -1 if none)
      currentPattern: -1
    };
    
    // Robust content manager to handle pattern switching and persistence
    AFRAME.registerSystem('ar-content-manager', {
      init: function() {
        this.sceneEl = this.el;
        this.currentActivePattern = -1;
        this.contentEntities = [];
        this.persistentParents = [];
        this.activePatternDisplay = document.getElementById('active-pattern');
        
        // Listen for all target events
        this.sceneEl.addEventListener('targetFound', this.onTargetFound.bind(this));
        this.sceneEl.addEventListener('targetLost', this.onTargetLost.bind(this));
        
        console.log('[AR Content Manager] Initialized');
      },
      
      registerContent: function(contentEntity, persistentParent, targetIndex) {
        this.contentEntities[targetIndex] = contentEntity;
        this.persistentParents[targetIndex] = persistentParent;
        console.log(`[AR Content Manager] Registered content for pattern ${targetIndex}`);
        
        // Store in global state for access by other components
        window.arPersistence.contentEntities[targetIndex] = contentEntity;
        window.arPersistence.persistentParents[targetIndex] = persistentParent;
      },
      
      onTargetFound: function(event) {
        const foundTargetIndex = parseInt(event.detail.name);
        console.log(`[AR Content Manager] Target ${foundTargetIndex} found`);
        
        // Set as current active pattern
        this.currentActivePattern = foundTargetIndex;
        window.arPersistence.currentPattern = foundTargetIndex;
        
        // Update the UI
        this.activePatternDisplay.textContent = `Active Pattern: ${foundTargetIndex + 1}`;
        
        // Show the appropriate content, hide others if needed
        this.showPatternContent(foundTargetIndex);
      },
      
      onTargetLost: function(event) {
        const lostTargetIndex = parseInt(event.detail.name);
        console.log(`[AR Content Manager] Target ${lostTargetIndex} lost`);
        
        // Don't hide content, it should persist
        // Just update UI if needed
        this.activePatternDisplay.textContent = `Pattern ${lostTargetIndex + 1} (tracking with motion)`;
      },
      
      showPatternContent: function(targetIndex) {
        // First make sure all persistent parents are handled correctly
        for (let i = 0; i < this.persistentParents.length; i++) {
          const parent = this.persistentParents[i];
          if (!parent) continue;
          
          if (i === targetIndex) {
            // Show this content
            parent.object3D.visible = true;
            parent.setAttribute('visible', true);
          } else {
            // Hide other content only if it's a different pattern
            // This ensures content persists until another pattern is detected
            parent.object3D.visible = false;
            parent.setAttribute('visible', false);
          }
        }
        
        // Extra check to ensure active content stays visible
        const activeParent = this.persistentParents[targetIndex];
        if (activeParent) {
          activeParent.object3D.visible = true;
          
          // Also make sure the content itself is visible
          const content = this.contentEntities[targetIndex];
          if (content) {
            content.object3D.visible = true;
            content.setAttribute('visible', true);
          }
        }
      },
      
      tick: function() {
        // Force visibility of current pattern content even if something tries to hide it
        if (this.currentActivePattern >= 0) {
          const activeParent = this.persistentParents[this.currentActivePattern];
          if (activeParent && !activeParent.object3D.visible) {
            activeParent.object3D.visible = true;
          }
          
          const content = this.contentEntities[this.currentActivePattern];
          if (content && !content.object3D.visible) {
            content.object3D.visible = true;
          }
        }
      }
    });
    
    // Component to decouple AR content from pattern targets
    AFRAME.registerComponent('ar-content', {
      schema: {
        targetIndex: { type: 'number', default: 0 },
        initialized: { type: 'boolean', default: false }
      },
      
      init: function() {
        this.sceneEl = document.querySelector('a-scene');
        this.contentManager = this.sceneEl.systems['ar-content-manager'];
        this.cameraEl = document.querySelector('a-camera');
        this.targetEntity = document.querySelector(`#target${this.data.targetIndex + 1}`);
        this.worldPosition = new THREE.Vector3();
        this.worldQuaternion = new THREE.Quaternion();
        this.targetDetected = false;
        this.wasEverVisible = false;
        this.decoupled = false;
        
        // Create a parent for the content that will be decoupled from pattern tracking
        this.persistentParent = document.createElement('a-entity');
        this.persistentParent.setAttribute('id', `persistent-parent-${this.data.targetIndex}`);
        this.persistentParent.setAttribute('visible', 'false');
        this.persistentParent.setAttribute('position', '0 0 0');
        this.persistentParent.setAttribute('rotation', '0 0 0');
        this.sceneEl.appendChild(this.persistentParent);
        
        // Register with the content manager
        if (this.contentManager) {
          this.contentManager.registerContent(this.el, this.persistentParent, this.data.targetIndex);
        } else {
          console.error(`[AR Content ${this.data.targetIndex}] Content manager not found`);
        }
        
        // Bind event handlers to this instance
        this.onTargetFound = this.onTargetFound.bind(this);
        this.onTargetLost = this.onTargetLost.bind(this);
        
        // Register event listeners
        this.sceneEl.addEventListener('targetFound', this.onTargetFound);
        this.sceneEl.addEventListener('targetLost', this.onTargetLost);
        
        console.log(`[AR Content ${this.data.targetIndex}] Initialized`);
      },
      
      onTargetFound: function(event) {
        const foundTargetIndex = parseInt(event.detail.name);
        if (foundTargetIndex !== this.data.targetIndex) return;
        
        console.log(`[AR Content ${this.data.targetIndex}] Pattern detected`);
        this.targetDetected = true;
        this.wasEverVisible = true;
        
        // Make sure content is visible
        this.el.object3D.visible = true;
        this.el.setAttribute('visible', true);
        
        // Get world position and rotation of the target
        if (this.targetEntity && this.targetEntity.object3D) {
          this.targetEntity.object3D.updateMatrixWorld();
          this.targetEntity.object3D.getWorldPosition(this.worldPosition);
          this.targetEntity.object3D.getWorldQuaternion(this.worldQuaternion);
          
          // Store in global state
          window.arPersistence.lastWorldPosition.copy(this.worldPosition);
          window.arPersistence.lastWorldQuaternion.copy(this.worldQuaternion);
          window.arPersistence.activeContent = this.data.targetIndex;
          window.arPersistence.hasDetectedPattern = true;
        }
        
        // If not already decoupled, decouple this content from the target
        if (!this.decoupled) {
          setTimeout(() => this.decoupleContent(), 50);
        }
      },
      
      onTargetLost: function(event) {
        const lostTargetIndex = parseInt(event.detail.name);
        if (lostTargetIndex !== this.data.targetIndex) return;
        
        console.log(`[AR Content ${this.data.targetIndex}] Pattern lost, but content remains visible`);
        this.targetDetected = false;
        
        // Explicitly keep content visible unless another pattern is detected
        if (this.persistentParent) {
          this.persistentParent.object3D.visible = true;
          this.persistentParent.setAttribute('visible', true);
        }
        
        this.el.object3D.visible = true;
        this.el.setAttribute('visible', true);
      },
      
      decoupleContent: function() {
        if (this.decoupled) return;
        
        try {
          // Clone this entity's position/rotation to the persistent parent
          this.persistentParent.object3D.position.copy(this.worldPosition);
          this.persistentParent.object3D.quaternion.copy(this.worldQuaternion);
          this.persistentParent.setAttribute('visible', true);
          
          // Move this entity to be a child of the persistent parent
          const currentParent = this.el.parentNode;
          if (currentParent) {
            currentParent.removeChild(this.el);
            this.persistentParent.appendChild(this.el);
            
            // Reset local position so it appears in the same world position
            this.el.object3D.position.set(0, 0, 0);
            this.el.object3D.rotation.set(0, 0, 0);
            
            // Mark as decoupled
            this.decoupled = true;
            console.log(`[AR Content ${this.data.targetIndex}] Successfully decoupled from target`);
          } else {
            console.error(`[AR Content ${this.data.targetIndex}] Cannot decouple: no parent found`);
          }
        } catch (error) {
          console.error(`[AR Content ${this.data.targetIndex}] Decoupling error:`, error);
        }
      },
      
      tick: function() {
        // Always ensure our content is visible if it should be
        if (this.wasEverVisible && this.data.targetIndex === window.arPersistence.currentPattern) {
          if (!this.el.object3D.visible) {
            this.el.object3D.visible = true;
          }
          if (this.persistentParent && !this.persistentParent.object3D.visible) {
            this.persistentParent.object3D.visible = true;
          }
        }
      },
      
      remove: function() {
        this.sceneEl.removeEventListener('targetFound', this.onTargetFound);
        this.sceneEl.removeEventListener('targetLost', this.onTargetLost);
      }
    });
    
    // Enhanced device motion tracking for persistent content
    AFRAME.registerComponent('motion-tracking', {
      schema: {
        enabled: { default: true }
      },
      
      init: function() {
        this.deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
        this.lastDeviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
        this.acceleration = { x: 0, y: 0, z: 0 };
        this.isSupported = 'DeviceOrientationEvent' in window && 'DeviceMotionEvent' in window;
        this.isCalibrated = false;
        this.orientationOffset = new THREE.Euler(0, 0, 0, 'YXZ');
        this.lastTimestamp = 0;
        
        this.deviceMotionHandler = this.deviceMotionHandler.bind(this);
        this.deviceOrientationHandler = this.deviceOrientationHandler.bind(this);
        
        console.log('[Motion Tracking] Component initialized');
      },
      
      update: function() {
        if (this.data.enabled) {
          this.enableTracking();
        } else {
          this.disableTracking();
        }
      },
      
      enableTracking: function() {
        if (!this.isSupported) return;
        
        // Request device orientation permissions if needed
        if (typeof DeviceOrientationEvent !== 'undefined' && 
            typeof DeviceOrientationEvent.requestPermission === 'function') {
          DeviceOrientationEvent.requestPermission()
            .then(permissionState => {
              if (permissionState === 'granted') {
                window.addEventListener('deviceorientation', this.deviceOrientationHandler);
              }
            })
            .catch(console.error);
        } else {
          window.addEventListener('deviceorientation', this.deviceOrientationHandler);
        }
        
        // Request device motion permissions if needed
        if (typeof DeviceMotionEvent !== 'undefined' && 
            typeof DeviceMotionEvent.requestPermission === 'function') {
          DeviceMotionEvent.requestPermission()
            .then(permissionState => {
              if (permissionState === 'granted') {
                window.addEventListener('devicemotion', this.deviceMotionHandler);
              }
            })
            .catch(console.error);
        } else {
          window.addEventListener('devicemotion', this.deviceMotionHandler);
        }
        
        console.log('Device motion tracking enabled');
      },
      
      disableTracking: function() {
        window.removeEventListener('deviceorientation', this.deviceOrientationHandler);
        window.removeEventListener('devicemotion', this.deviceMotionHandler);
        console.log('Device motion tracking disabled');
      },
      
      deviceOrientationHandler: function(event) {
        if (!this.data.enabled) return;
        
        // Store orientation data in radians
        this.lastDeviceOrientation = { ...this.deviceOrientation };
        this.deviceOrientation.alpha = THREE.MathUtils.degToRad(event.alpha || 0);
        this.deviceOrientation.beta = THREE.MathUtils.degToRad(event.beta || 0);
        this.deviceOrientation.gamma = THREE.MathUtils.degToRad(event.gamma || 0);
        
        // Calibrate if not yet done
        if (!this.isCalibrated && window.arPersistence.hasDetectedPattern) {
          this.calibrate();
        }
      },
      
      deviceMotionHandler: function(event) {
        if (!this.data.enabled) return;
        
        const now = performance.now();
        const dt = (now - this.lastTimestamp) / 1000; // convert to seconds
        this.lastTimestamp = now;
        
        if (!dt || dt > 1) return; // Skip large time gaps or first reading
        
        // Get acceleration with gravity removed
        const acceleration = event.accelerationIncludingGravity;
        if (acceleration && acceleration.x !== null) {
          // Simple low-pass filter to reduce noise - reduce alpha for faster response
          const alpha = 0.5; // Even more responsive
          this.acceleration.x = alpha * this.acceleration.x + (1 - alpha) * acceleration.x;
          this.acceleration.y = alpha * this.acceleration.y + (1 - alpha) * acceleration.y;
          this.acceleration.z = alpha * this.acceleration.z + (1 - alpha) * acceleration.z;
        }
      },
      
      calibrate: function() {
        // Save the current orientation as the offset
        this.orientationOffset.set(
          this.deviceOrientation.beta,
          this.deviceOrientation.alpha,
          this.deviceOrientation.gamma
        );
        this.isCalibrated = true;
        console.log('Motion tracking calibrated');
      },
      
      tick: function() {
        if (!this.data.enabled || !this.isCalibrated || !window.arPersistence.hasDetectedPattern) return;
        
        // Get current active pattern index
        const activePatternIndex = window.arPersistence.currentPattern;
        if (activePatternIndex < 0) return;
        
        // Get the persistent parent of the active pattern
        const activeParent = window.arPersistence.persistentParents[activePatternIndex];
        if (!activeParent || !activeParent.object3D) return;
        
        // Calculate orientation difference from last frame
        const deltaAlpha = this.deviceOrientation.alpha - this.lastDeviceOrientation.alpha;
        const deltaBeta = this.deviceOrientation.beta - this.lastDeviceOrientation.beta;
        const deltaGamma = this.deviceOrientation.gamma - this.lastDeviceOrientation.gamma;
        
        // Apply device motion to the active pattern's persistent parent
        activeParent.object3D.rotation.y -= deltaAlpha * 0.8;
        activeParent.object3D.rotation.x += deltaBeta * 0.8;
        activeParent.object3D.rotation.z += deltaGamma * 0.8;
      },
      
      remove: function() {
        this.disableTracking();
      }
    });
  </script>

  <!-- Optimized A-Frame scene with better detection parameters -->
  <a-scene ar-content-manager
    mindar-image="imageTargetSrc: ./targets/targets.mind; maxTrack: 3; filterMinCF:0.00001; filterBeta: 0.1; warmupTolerance: 15; missTolerance: 20" 
    color-space="sRGB" 
    renderer="antialias: false; precision: medium; colorManagement: true; physicallyCorrectLights: false" 
    vr-mode-ui="enabled: false" 
    device-orientation-permission-ui="enabled: false" 
    loading-screen="enabled: false">
    
    <a-assets>
      <!-- Audio assets -->
      <audio id="sound-1" src="assets/sound1.mp3" preload="auto"></audio>
      <audio id="sound-2" src="assets/sound2.mp3" preload="auto"></audio>
      <audio id="sound-3" src="assets/sound3.mp3" preload="auto"></audio>
    </a-assets>

    <a-camera position="0 0 0" look-controls="enabled: false" motion-tracking="enabled: true"></a-camera>
    
    <!-- Pattern 1 with content -->
    <a-entity id="target1" mindar-image-target="targetIndex: 0">
      <a-entity id="content-pattern1" ar-content="targetIndex: 0">
        <a-box id="box1" position="0 0.1 0" rotation="0 0 0" scale="0.1 0.1 0.1" color="red" animation="property: rotation; to: 0 360 0; loop: true; dur: 5000; easing: linear;">
          <a-animation begin="click" attribute="scale" to="0.15 0.15 0.15" dur="300" direction="alternate" repeat="1"></a-animation>
        </a-box>
        <a-text value="Pattern 1" position="0 0.25 0" scale="0.5 0.5 0.5" align="center" color="#FFF" side="double"></a-text>
      </a-entity>
    </a-entity>
    
    <!-- Pattern 2 with content -->
    <a-entity id="target2" mindar-image-target="targetIndex: 1">
      <a-entity id="content-pattern2" ar-content="targetIndex: 1">
        <a-sphere id="sphere1" position="0 0.1 0" radius="0.05" color="blue" animation="property: position; to: 0 0.2 0; dir: alternate; dur: 1000; loop: true; easing: easeInOutQuad;">
          <a-animation begin="click" attribute="color" from="blue" to="purple" dur="500" direction="alternate" repeat="2"></a-animation>
        </a-sphere>
        <a-text value="Pattern 2" position="0 0.25 0" scale="0.5 0.5 0.5" align="center" color="#FFF" side="double"></a-text>
      </a-entity>
    </a-entity>
    
    <!-- Pattern 3 with content -->
    <a-entity id="target3" mindar-image-target="targetIndex: 2">
      <a-entity id="content-pattern3" ar-content="targetIndex: 2">
        <a-cylinder id="cylinder1" position="0 0.1 0" radius="0.05" height="0.1" color="green" animation="property: rotation; to: 90 360 90; loop: true; dur: 5000; easing: linear;">
          <a-animation begin="click" attribute="height" to="0.2" dur="500" direction="alternate" repeat="1"></a-animation>
        </a-cylinder>
        <a-text value="Pattern 3" position="0 0.25 0" scale="0.5 0.5 0.5" align="center" color="#FFF" side="double"></a-text>
        <a-entity position="0.15 0.1 0" scale="0.05 0.05 0.05">
          <a-torus-knot radius="0.5" radius-tubular="0.05" p="3" q="7" color="yellow" animation="property: rotation; to: 360 360 0; loop: true; dur: 10000;"></a-torus-knot>
        </a-entity>
      </a-entity>
    </a-entity>
  </a-scene>
</body>
</html>